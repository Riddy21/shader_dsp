#!/usr/bin/env python3
"""
ADSR Envelope Visualization Script

This script reads CSV files generated by the ADSR envelope tests and creates
comprehensive visualizations showing:
1. Envelope shape over time
2. Derivative (rate of change) over time  
3. Phase annotations (Attack, Decay, Sustain, Release)
4. Smoothness analysis

Usage: python visualize_envelope.py [csv_file_pattern]
If no pattern is provided, it will look for all envelope_data_*.csv files
"""

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import glob
import sys
import os

def analyze_envelope_phases(time, envelope, attack_time, decay_time, sustain_level, release_time):
    """
    Analyze and identify ADSR phases based on envelope shape and parameters
    """
    # Find note start (when envelope first becomes > 0)
    start_idx = np.where(envelope > 0.001)[0]
    if len(start_idx) == 0:
        return {}, []
    
    start_time = time[start_idx[0]]
    
    # Find approximate note stop (when envelope starts final descent to 0)
    # Look for the point where envelope starts decreasing towards 0
    max_idx = np.argmax(envelope)
    end_candidates = []
    
    # Look for sustained periods and then release
    for i in range(max_idx, len(envelope) - 10):
        # Check if we're in a relatively stable region followed by decline
        if i < len(envelope) - 20:
            current_level = envelope[i]
            future_decline = np.mean(envelope[i+10:i+20]) < current_level * 0.9
            if future_decline and current_level > 0.1:
                end_candidates.append(i)
                break
    
    if end_candidates:
        stop_idx = end_candidates[0]
        stop_time = time[stop_idx]
    else:
        # Fallback: assume note stops when envelope is at 50% of max after peak
        peak_val = envelope[max_idx]
        post_peak = envelope[max_idx:]
        sustain_candidates = np.where(post_peak < peak_val * 0.8)[0]
        if len(sustain_candidates) > 0:
            stop_idx = max_idx + sustain_candidates[len(sustain_candidates)//2]
            stop_time = time[stop_idx]
        else:
            stop_time = time[-1] - release_time
            stop_idx = len(time) - 1
    
    phases = {
        'attack_end': start_time + attack_time,
        'decay_end': start_time + attack_time + decay_time,
        'release_start': stop_time,
        'release_end': stop_time + release_time
    }
    
    # Create phase labels for plotting
    phase_regions = []
    phase_regions.append((start_time, phases['attack_end'], 'Attack', 'lightcoral'))
    phase_regions.append((phases['attack_end'], phases['decay_end'], 'Decay', 'lightblue'))
    phase_regions.append((phases['decay_end'], phases['release_start'], 'Sustain', 'lightgreen'))
    phase_regions.append((phases['release_start'], min(phases['release_end'], time[-1]), 'Release', 'lightyellow'))
    
    return phases, phase_regions

def plot_envelope_analysis(csv_file):
    """
    Create comprehensive visualization of envelope data
    """
    # Read the CSV file
    try:
        df = pd.read_csv(csv_file)
    except FileNotFoundError:
        print(f"Error: Could not find file {csv_file}")
        return
    except pd.errors.EmptyDataError:
        print(f"Error: File {csv_file} is empty")
        return
    
    if df.empty:
        print(f"Warning: No data in {csv_file}")
        return
    
    time = df['time'].values
    envelope = df['envelope'].values
    derivative = df['derivative'].values if 'derivative' in df.columns else np.gradient(envelope, time)
    second_derivative = df['second_derivative'].values if 'second_derivative' in df.columns else np.gradient(derivative, time[1:] if len(time) > len(derivative) else time)
    
    # Extract configuration from filename
    config_name = os.path.basename(csv_file).replace('envelope_data_', '').replace('.csv', '')
    
    # Estimate ADSR parameters from the data for phase analysis
    # These are rough estimates - in a real application you'd pass the actual parameters
    max_env = np.max(envelope)
    max_idx = np.argmax(envelope)
    
    # Rough parameter estimation
    attack_time = 0.1
    
    sustain_level = 0.7
    
    decay_time = 0.2  # Estimate
    release_time = 0.3  # Estimate
    
    phases, phase_regions = analyze_envelope_phases(time, envelope, attack_time, decay_time, sustain_level, release_time)
    
    # Create figure with subplots
    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
    fig.suptitle(f'ADSR Envelope Analysis: {config_name}', fontsize=16, fontweight='bold')
    
    # Plot 1: Envelope shape with phase regions
    ax1 = axes[0]
    ax1.plot(time, envelope, 'b-', linewidth=2, label='Envelope')
    ax1.set_ylabel('Amplitude', fontsize=12)
    ax1.set_title('Envelope Shape', fontsize=14)
    ax1.grid(True, alpha=0.3)
    ax1.legend()
    
    # Add phase regions
    for start_time, end_time, phase_name, color in phase_regions:
        if start_time < time[-1] and end_time > time[0]:
            ax1.axvspan(start_time, end_time, alpha=0.2, color=color, label=phase_name)
    
    # Add phase labels
    handles, labels = ax1.get_legend_handles_labels()
    by_label = dict(zip(labels, handles))
    ax1.legend(by_label.values(), by_label.keys(), loc='upper right')
    
    # Plot 2: Derivative (rate of change)
    ax2 = axes[1]
    ax2.plot(time[1:-1], derivative[1:-1], 'r-', linewidth=1.5, label='Derivative (Rate of Change)')
    ax2.set_ylabel('Rate of Change', fontsize=12)
    ax2.set_title('Envelope Derivative (Smoothness Analysis)', fontsize=14)
    ax2.grid(True, alpha=0.3)
    ax2.legend()
    
    # Highlight potential sharp edges
    derivative_threshold = np.std(derivative) * 3  # 3 standard deviations
    sharp_points = np.where(np.abs(derivative) > derivative_threshold)[0]
    if len(sharp_points) > 0:
        ax2.scatter(time[sharp_points], derivative[sharp_points], 
                   color='red', s=30, alpha=0.7, label='Potential Sharp Edges')
        ax2.legend()
    
    # Plot 3: Second derivative (curvature analysis)
    ax3 = axes[2]
    if 'second_derivative' in df.columns:
        # Use the pre-computed second derivative from CSV
        ax3.plot(time, second_derivative, 'g-', linewidth=1.5, label='Second Derivative (Curvature)')
    else:
        # Compute it on the fly
        computed_second_derivative = np.gradient(derivative)
        ax3.plot(time[1:-1], computed_second_derivative[1:-1], 'g-', linewidth=1.5, label='Second Derivative (Curvature)')
        second_derivative = computed_second_derivative
    ax3.set_xlabel('Time (seconds)', fontsize=12)
    ax3.set_ylabel('Curvature', fontsize=12)
    ax3.set_title('Envelope Curvature Analysis', fontsize=14)
    ax3.grid(True, alpha=0.3)
    ax3.legend()
    
    # Add statistics
    stats_text = f"""Statistics:
Max Amplitude: {max_env:.3f}
Max |Derivative|: {np.max(np.abs(derivative)):.2f}
Max |Curvature|: {np.max(np.abs(second_derivative)):.2f}
RMS Derivative: {np.sqrt(np.mean(derivative**2)):.2f}
Sharp Edge Count: {len(sharp_points)}"""
    
    fig.text(0.02, 0.02, stats_text, fontsize=10, verticalalignment='bottom',
             bbox=dict(boxstyle='round', facecolor='lightgray', alpha=0.8))
    
    plt.tight_layout()
    
    # Save the plot
    output_file = csv_file.replace('.csv', '_analysis.png')
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"Analysis plot saved to {output_file}")
    
    return fig

def main():
    """
    Main function to process CSV files and generate visualizations
    """
    # Determine which files to process
    if len(sys.argv) > 1:
        csv_pattern = sys.argv[1]
    else:
        # Look for both the new single file and old multiple file patterns
        csv_pattern = "envelope_analysis_data.csv"
        if not os.path.exists(csv_pattern):
            csv_pattern = "envelope_shape_*.csv"
    
    if csv_pattern.endswith('.csv'):
        csv_files = [csv_pattern] if os.path.exists(csv_pattern) else []
    else:
        csv_files = glob.glob(csv_pattern)
    
    if not csv_files:
        print(f"No CSV files found matching pattern: {csv_pattern}")
        print("Make sure to run the ADSR envelope tests first to generate the data files.")
        print("Expected files: envelope_analysis_data.csv or envelope_data_*.csv")
        return
    
    print(f"Found {len(csv_files)} CSV files to process:")
    for f in csv_files:
        print(f"  - {f}")
    
    # Process each file
    figures = []
    for csv_file in sorted(csv_files):
        print(f"\nProcessing {csv_file}...")
        try:
            fig = plot_envelope_analysis(csv_file)
            if fig:
                figures.append(fig)
        except Exception as e:
            print(f"Error processing {csv_file}: {e}")
    
    # Show all plots
    if figures:
        print(f"\nGenerated {len(figures)} analysis plots.")
        print("Close the plot windows when done viewing.")
        plt.show()
    else:
        print("No plots were generated.")

if __name__ == "__main__":
    main()